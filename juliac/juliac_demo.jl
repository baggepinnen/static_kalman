module StateEstimator

using LowLevelParticleFilters
using Random, LinearAlgebra, StaticArrays
println(Core.stdout, 0)


const dynamics = function (ˍ₋arg1, ˍ₋arg2, ˍ₋arg3, t)
    SA[(+)((+)((*)((*)(-9.043e9, (exp)((/)(-8560.0, (+)(273.15, ˍ₋arg1[3])))), (abs2)(ˍ₋arg1[1])), (*)((+)(5.1, (*)(-1, ˍ₋arg1[1])), ˍ₋arg2[1])), (*)((*)(-1.287e12, ˍ₋arg1[1]), (exp)((/)(-9758.3, (+)(273.15, ˍ₋arg1[3]))))), (+)((+)((*)((*)(1.287e12, ˍ₋arg1[1]), (exp)((/)(-9758.3, (+)(273.15, ˍ₋arg1[3])))), (*)((*)(-1.0, ˍ₋arg1[2]), ˍ₋arg2[1])), (*)((*)(-1.287e12, ˍ₋arg1[2]), (exp)((/)(-9758.3, (+)(273.15, ˍ₋arg1[3]))))), (+)((+)((*)(30.828516377649326, (+)(ˍ₋arg1[4], (*)(-1, ˍ₋arg1[3]))), (*)(-0.35562611177613196, (+)((+)((*)((*)(-3.7844955e11, (exp)((/)(-8560.0, (+)(273.15, ˍ₋arg1[3])))), (abs2)(ˍ₋arg1[1])), (*)((*)(5.4054e12, ˍ₋arg1[1]), (exp)((/)(-9758.3, (+)(273.15, ˍ₋arg1[3]))))), (*)((*)(-1.4157e13, ˍ₋arg1[2]), (exp)((/)(-9758.3, (+)(273.15, ˍ₋arg1[3]))))))), (*)((+)(130.0, (*)(-1, ˍ₋arg1[3])), ˍ₋arg2[1])), (*)(0.1, (+)((*)(866.88, (+)((*)(-1, ˍ₋arg1[4]), ˍ₋arg1[3])), ˍ₋arg2[2]))]
end

const Ts  = 0.005 # sample time
const x0  = SA[0.8, 0.5, 134.14, 130] # Initial state
const u0 = SA[12.0, -4000] # Initial input
const p = nothing

const lb = SA[0.1, 0.1, 50, 50, 5, -8500]
const ub = SA[2, 2, 142, 140, 100, 0.0]
measurement(x,u,p,t) = x # We can measure the full state
const discrete_dynamics = LowLevelParticleFilters.rk4(dynamics, Ts)
discrete_dynamics(x0, u0, p, 0.0)



typical_magnitudes = x0

const nx = 4 # Dimension of state
const nu = 2 # Dimension of input
const ny = 4 # Dimension of measurements

const R1 = SMatrix{nx,nx}(Diagonal(typical_magnitudes .^ 2 ./ 10))
const R2 = SMatrix{nx,nx}(Diagonal(typical_magnitudes .^ 2 ./ 10))

const d0 = LowLevelParticleFilters.SimpleMvNormal(x0,R1)   # Initial state Distribution

println(Core.stdout, 1)
# const kf   = KalmanFilter(_A, _B, _C, 0, R1, R2, d0, check=false)
const kf = UnscentedKalmanFilter((x,u,p,t)->discrete_dynamics(x,u,p,t), measurement, R1, R2, d0; ny, nu, p=nothing) # The silly identity function avoids a segfault in has_ip
println(Core.stdout, 2)

Base.@ccallable function main()::Cint
    println(Core.stdout, "I'm alive and well")

    # Fake some input data
    T = 30 # Number of time steps
    u = [u0 for _ in 1:T]
    y = SVector{4, Float64}[[0.4000000000000001, 0.24999999999999994, 67.06999999999998, 65.0], [0.6992362329119995, 0.29133164654415056, 69.7967297569027, 64.2961041966717], [0.9445815687517278, 0.4170366263343849, 95.7018379743395, 87.97954367423525], [0.5985932907652429, 0.9171044707080842, 124.86678919829181, 110.72430534054124], [0.46914601511576604, 1.5866214395987646, 120.0808941283529, 118.62558245683672], [0.11475411127773427, 2.140408650869615, 113.54281919161194, 117.54007097741592], [-0.09061192359722314, 2.2816792930285494, 125.66717627744217, 120.32532948969866], [-0.20736485696198803, 2.631519041662495, 128.0885038635681, 123.56854124963004], [-0.2521283512873376, 2.6911566931835234, 128.48504768453463, 124.34642930777068], [-0.2737826952217998, 2.71556212856894, 128.46223308562398, 124.52195477076317], [-0.28404266652151733, 2.7253534396688357, 128.40479846354032, 124.53999455454351], [-0.28876452818578674, 2.729194485734303, 128.36550716651973, 124.52660109513725], [-0.2908830649400569, 2.730676089162396, 128.34365815036327, 124.51304255104333], [-0.291813737758393, 2.731239163784335, 128.3325507155386, 124.50436255423153], [-0.2922154668824627, 2.731450115506358, 128.32719512140721, 124.49960702734381], [-0.2923863120255631, 2.731527999320581, 128.32470503603818, 124.49720411699897], [-0.2924580365160852, 2.731556308540233, 128.3235783155682, 124.49604994243472], [-0.29248780644489697, 2.731566421497165, 128.32307931560146, 124.49551483463814], [-0.2925000365961147, 2.731569962570256, 128.32286217407403, 124.49527324197122], [-0.2925050141666067, 2.7315711729265884, 128.3227690779745, 124.49516642908338], [-0.2925070225192039, 2.7315715741649624, 128.32272967396105, 124.49512001013784], [-0.29250782630711925, 2.7315717017851955, 128.3227131835628, 124.49510012839447], [-0.29250814554456017, 2.7315717399708492, 128.32270635208116, 124.49509171929188], [-0.29250827141054137, 2.7315717502772365, 128.32270354797834, 124.49508820189102], [-0.29250832068738325, 2.7315717525053715, 128.32270240670738, 124.49508674520263], [-0.29250833984781915, 2.7315717526833883, 128.32270194585962, 124.49508614737755], [-0.29250834724830826, 2.731571752489696, 128.3227017611418, 124.4950859040701], [-0.2925083500878569, 2.7315717523152565, 128.32270168762048, 124.49508580581356], [-0.29250835117028506, 2.731571752210541, 128.32270165855317, 124.49508576642265], [-0.29250835158020877, 2.731571752156312, 128.32270164713475, 124.49508575073978]]

    sol = forward_trajectory(kf, u, y)
    println(Core.stdout, "I got loglik = ", sol.ll)
    return zero(Cint)
end

end


# compile using something like
# run(`julia +nightly --project=/home/fredrikb/Desktop/semi_tmp/static_kalman/juliac /home/fredrikb/repos/julia/contrib/juliac.jl --output-exe juliac_demo --trim=unsafe-warn /home/fredrikb/Desktop/semi_tmp/static_kalman/juliac/juliac_demo.jl`)
# run(`ls -ltrh`) # marvel at the smallness of the binary
# run(`./juliac_demo`)